import os
import math
import struct
import random
import logging
import winsound
import ctypes
import tempfile
import shutil

class SoundManager:
    """
    Manages game audio effects, including dynamic wave generation and playback.
    Supports stereo panning, frequency sweeps, and in-memory audio buffering.
    """
    def __init__(self):
        """Initializes the SoundManager, sets up temp directories, and pre-generates sounds."""
        # Use a hidden temp dir in system's temp location
        system_temp = tempfile.gettempdir()
        self.temp_dir = os.path.join(system_temp, "2048_Accesible_Sfx")
        if not os.path.exists(self.temp_dir):
            os.makedirs(self.temp_dir)
            
        self.sounds = {}
        self.dynamic_cache = {} # Cache for generated bytes
        logging.info(f"SoundManager initialized. Temp dir: {self.temp_dir}")
        
        # Cleanup old visible folder if it exists (~/.2048_sounds)
        self._cleanup_old_folder()
        
        # Test System Audio
        try:
            logging.info("Testing system audio with MessageBeep.")
            try:
                winsound.MessageBeep(winsound.MB_OK) # type: ignore
            except AttributeError:
                 # winsound might be limited on some envs
                 pass
        except Exception as e:
            logging.error(f"System Audio Test Failed: {e}")

        try:
            self._pregenerate_defaults()
        except Exception as e:
            logging.error(f"Pregeneration failed: {e}")
            # wx.MessageBox might not be safe here if App not init, but usually ok
            # wx.MessageBox(f"Error generando sonidos: {e}", "Error de Audio")

    def _cleanup_old_folder(self):
        old_path = os.path.join(os.path.expanduser("~"), ".2048_sounds")
        if os.path.exists(old_path):
            try:
                # We use shutil.rmtree to remove the folder and its contents
                # if it's not currently locked (unlikely on startup)
                shutil.rmtree(old_path, ignore_errors=True)
                logging.info(f"Cleaned up legacy sound folder: {old_path}")
            except Exception as e:
                logging.warning(f"Could not remove legacy folder {old_path}: {e}")

    def _generate_wave(self, freq_start, freq_end, duration, vol=0.5, pan_start=0.0, pan_end=None):
        """Genera datos WAV estéreo con barrido de frecuencia y paneo."""
        if pan_end is None: pan_end = pan_start
        
        sample_rate = 44100
        n_samples = int(sample_rate * duration)
        
        data_pcm = bytearray()
        
        phase = 0.0
        
        # Parámetros de Envolvente (ADSR simple solo con Decay)
        # Ataque: muy rápido (0.005s) para "golpe" metálico
        # Decay: exponencial largo para "ringing"
        attack_samples = int(sample_rate * 0.005)
        
        for i in range(n_samples):
            progress = float(i) / n_samples
            
            # Simple Linear Glide
            f_current = freq_start + (freq_end - freq_start) * progress
            
            phase += 2 * math.pi * f_current / sample_rate
            
            # Use new tile helper
            val = self._compute_tile_sample(phase, f_current, sample_rate, float(i)/sample_rate)
            
            # Simple Exponential Decay
            env = 1.0
            if i < attack_samples:
                env = i / max(1, attack_samples)
            else:
                # Faster Decay for "Thud" / "Click" (Tile aesthetic)
                decay_div = max(1, n_samples - attack_samples)
                decay_progress = (i - attack_samples) / decay_div
                env = math.exp(-8.0 * decay_progress) 
            
            # Paneo
            current_pan = pan_start + (pan_end - pan_start) * progress
            
            left_factor = max(0.0, min(1.0, 0.5 * (1.0 - current_pan) * 2.0))
            right_factor = max(0.0, min(1.0, 0.5 * (1.0 + current_pan) * 2.0))
            
            # Vol (Boosted slightly)
            base_sample = int(val * 32700.0 * vol * env)
            
            left_sample = max(-32767, min(32767, int(base_sample * left_factor)))
            right_sample = max(-32767, min(32767, int(base_sample * right_factor)))
            
            data_pcm.extend(struct.pack('<h', left_sample))
            data_pcm.extend(struct.pack('<h', right_sample))
            
        return self._wrap_wav_header(data_pcm)

    def _wrap_wav_header(self, pcm_data):
        header = struct.pack('<4sI4s', b'RIFF', 36 + len(pcm_data), b'WAVE')
        fmt = struct.pack('<4sIHHIIHH', b'fmt ', 16, 1, 2, 44100, 44100 * 4, 4, 16)
        data_hdr = struct.pack('<4sI', b'data', len(pcm_data))
        return header + fmt + data_hdr + pcm_data

    def _save_temp_sound(self, name, data):
        path = os.path.join(self.temp_dir, f"{name}.wav")
        try:
            with open(path, "wb") as f:
                f.write(data)
            logging.info(f"Saved sound {name} to {path} ({len(data)} bytes)")
        except Exception as e:
            logging.error(f"Failed to save {name}: {e}")
        return path

    def _pregenerate_defaults(self):
        # Safe Defaults
        data = self._generate_wave(200, 400, 0.2, 0.8, pan_start=0.0)
        self.sounds['MOVE'] = self._save_temp_sound('MOVE', data)
        
        data = self._generate_wave(200, 400, 0.2, 0.8, pan_start=-0.8)
        self.sounds['MOVE_L'] = self._save_temp_sound('MOVE_L', data)
        
        data = self._generate_wave(200, 400, 0.2, 0.8, pan_start=0.8)
        self.sounds['MOVE_R'] = self._save_temp_sound('MOVE_R', data)
        
        data = self._generate_wave(100, 50, 0.3, 0.8, pan_start=0.0)
        self.sounds['INVALID'] = self._save_temp_sound('INVALID', data)
        
        data = self._generate_wave(400, 100, 0.5, 0.8, pan_start=0.0)
        self.sounds['GAMEOVER'] = self._save_temp_sound('GAMEOVER', data)
        
        # UI Sounds
        # Undo: Reverse sweep / Rewind
        data = self._generate_wave(150, 50, 0.2, 0.4, pan_start=0.0)
        self.sounds['UNDO'] = self._save_temp_sound('UNDO', data)
        
        # Toggle ON (High Blip)
        data = self._generate_wave(880, 880, 0.05, 0.3)
        self.sounds['TOGGLE_ON'] = self._save_temp_sound('TOGGLE_ON', data)
        
        # Toggle OFF (Low Blip)
        data = self._generate_wave(440, 440, 0.05, 0.3)
        self.sounds['TOGGLE_OFF'] = self._save_temp_sound('TOGGLE_OFF', data)
        
        # High Score Fanfare (Major Triad Arpeggio)
        fanfare_notes = [523.25, 659.25, 783.99, 1046.50]
        data = self._generate_sequence(fanfare_notes, 0.1, 0.4)
        self.sounds['HIGHSCORE'] = self._save_temp_sound('HIGHSCORE', data)
        
        # Restart: Quick major arpeggio
        restart_freqs = [261.63, 329.63, 392.00, 523.25]
        data = self._generate_sequence(restart_freqs, 0.05, 0.4)
        self.sounds['RESTART'] = self._save_temp_sound('RESTART', data)

    def play(self, name_or_data):
        """Reproduce un sonido por nombre predefinido o datos WAV crudos."""
        filepath = None
        
        if isinstance(name_or_data, str):
            filepath = self.sounds.get(name_or_data)
        elif isinstance(name_or_data, (bytes, bytearray)):
            # Memory Playback (FAST)
            try:
                winmm = ctypes.windll.winmm # type: ignore
                # SND_ASYNC=1, SND_MEMORY=4, SND_NODEFAULT=2
                flags = 0x0001 | 0x0004 | 0x0002
                winmm.PlaySoundW(bytes(name_or_data), 0, flags) # type: ignore
                return
            except Exception as e:
                logging.error(f"Memory playback failed: {e}")
                # Fallback to winsound
                try:
                    winsound.PlaySound(name_or_data, winsound.SND_MEMORY | winsound.SND_ASYNC | winsound.SND_NODEFAULT) # type: ignore
                    return
                except Exception: pass

        if filepath and os.path.exists(filepath):
            try:
                # Método principal: ctypes winmm (Windows)
                winmm = ctypes.windll.winmm # type: ignore
                # SND_ASYNC=1, SND_FILENAME=0x20000, SND_NODEFAULT=2
                flags = 0x0001 | 0x00020000 | 0x0002
                winmm.PlaySoundW(filepath, 0, flags) # type: ignore
            except AttributeError:
                # Fallback para entornos sin winmm (e.g. Wine, tests)
                try:
                    winsound.PlaySound(filepath, winsound.SND_FILENAME | winsound.SND_ASYNC | winsound.SND_NODEFAULT) # type: ignore
                except Exception as e2:
                    logging.warning(f"Fallback audio también falló: {e2}")
            except Exception as e:
                logging.error(f"Error playing sound {filepath}: {e}")
        else:
            if isinstance(name_or_data, str):
                logging.warning(f"Sound not found: {name_or_data}")

    def get_merge_sound(self, start_pan, end_pan, intensity=1):
        """Genera un sonido dinámico de fusión con paneo e intensidad variable."""
        cache_key = f"merge_{start_pan}_{end_pan}_{intensity}"
        if cache_key in self.dynamic_cache:
            return self.dynamic_cache[cache_key]
        
        duration = 0.15 + (min(intensity, 20) * 0.02)
        base_step = 60.0 
        start_freq = 250.0 + ((intensity - 1) * base_step)
        sweep_range = 150.0 
        freq_end = start_freq + sweep_range
        
        data = self._generate_wave(start_freq, freq_end, duration, 0.8, pan_start=start_pan, pan_end=end_pan)
        self.dynamic_cache[cache_key] = data
        return data

    def _compute_tile_sample(self, phase, freq, sample_rate, time_t):
        val = 0.0
        
        # 1. Body (Wood/Stone block)
        val += 1.0 * math.sin(phase)
        # Hollow Clack (Odd harmonics)
        val += 0.5 * math.sin(phase * 3.0) 
        val += 0.25 * math.sin(phase * 5.0)
        # Inharmonic "Material" resonance
        val += 0.1 * math.sin(phase * 2.4)
        
        # 2. Noise Click (Impact)
        if time_t < 0.01:
            noise = (random.random() - 0.5) * 2.0
            noise_env = 1.0 - (time_t / 0.01)
            val += noise * 0.8 * noise_env
            
        return val / 2.0 

    def _generate_sequence(self, freqs, note_duration, vol=0.5):
        # Generar secuencia de notas (arpegio)
        final_pcm = bytearray()
        sample_rate = 44100
        n_samples_note = int(sample_rate * note_duration)
        
        attack_samples = int(sample_rate * 0.005)

        for f in freqs:
            phase = 0.0
            
            for i in range(n_samples_note):
                phase += 2 * math.pi * f / sample_rate
                
                val = self._compute_tile_sample(phase, f, sample_rate, float(i)/sample_rate)
                
                env = 1.0
                if i < attack_samples:
                    env = i / max(1, attack_samples)
                else:
                    decay_div = max(1, n_samples_note - attack_samples)
                    decay_prog = (i - attack_samples) / decay_div
                    env = math.exp(-2.0 * decay_prog) 
                    env = env * 0.8 + 0.2 * (1.0 - decay_prog)
                
                sample_val = max(-32767, min(32767, int(val * 32767.0 * vol * env)))
                
                final_pcm.extend(struct.pack('<h', sample_val))
                final_pcm.extend(struct.pack('<h', sample_val))
                
        return self._wrap_wav_header(final_pcm)

    def get_record_sound(self, value):
        """Genera un arpegio ascendente para celebrar un nuevo récord de ficha."""
        if value < 8 or value <= 0:
            return None
        
        log_val = int(math.log2(value))
        
        num_notes = max(2, log_val - 2)
        
        start_freq = 220.0 + (log_val * 20) 
        
        freqs = []
        current_f = start_freq
        
        for i in range(num_notes):
            freqs.append(current_f)
            current_f *= 1.25 # Major Thirds
            
        note_dur = 0.08 
        
        return self._generate_sequence(freqs, note_dur, 0.4)

    def get_move_sound(self, direction, intensity):
        """Genera un sonido direccional de movimiento."""
        cache_key = f"move_{direction}_{intensity}"
        if cache_key in self.dynamic_cache:
            return self.dynamic_cache[cache_key]
            
        base_freq = 150 + (min(intensity, 10) * 10)
        
        data = None
        if direction == 'IZQUIERDA':
            data = self._generate_wave(base_freq, base_freq + 100, 0.15, 0.4, pan_start=0.0, pan_end=-0.8)
        elif direction == 'DERECHA':
            data = self._generate_wave(base_freq, base_freq + 100, 0.15, 0.4, pan_start=0.0, pan_end=0.8)
        elif direction == 'ARRIBA':
            data = self._generate_wave(base_freq, base_freq + 150, 0.15, 0.4, pan_start=0.0, pan_end=0.0)
        elif direction == 'ABAJO':
            data = self._generate_wave(base_freq + 150, base_freq, 0.15, 0.4, pan_start=0.0, pan_end=0.0)
            
        if data:
            self.dynamic_cache[cache_key] = data
        return data
